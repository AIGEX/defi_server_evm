// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: swap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
    type CallOptions,
    ChannelCredentials,
    Client,
    type ClientOptions,
    type ClientUnaryCall,
    type handleUnaryCall,
    makeGenericClientConstructor,
    Metadata,
    type ServiceError,
    type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "defi";

/** Message representing a request to perform a swap */
export interface SwapRequest {
    userId: string;
    fromToken: string;
    toToken: string;
    amount: number;
    maxSlippage: number;
}

/** Message representing the response of a swap operation */
export interface SwapResponse {
    /** Response code (e.g., 0 for success, non-zero for error) */
    code: number;
    message: string;
    txHash: string;
}

function createBaseSwapRequest(): SwapRequest {
    return { userId: "", fromToken: "", toToken: "", amount: 0, maxSlippage: 0 };
}

export const SwapRequest: MessageFns<SwapRequest> = {
    encode(message: SwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.fromToken !== "") {
            writer.uint32(18).string(message.fromToken);
        }
        if (message.toToken !== "") {
            writer.uint32(26).string(message.toToken);
        }
        if (message.amount !== 0) {
            writer.uint32(33).double(message.amount);
        }
        if (message.maxSlippage !== 0) {
            writer.uint32(40).int32(message.maxSlippage);
        }

        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SwapRequest {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwapRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.userId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.fromToken = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.toToken = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 33) {
                        break;
                    }

                    message.amount = reader.double();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }

                    message.maxSlippage = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 49) {
                        break;
                    }

                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): SwapRequest {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            fromToken: isSet(object.fromToken) ? globalThis.String(object.fromToken) : "",
            toToken: isSet(object.toToken) ? globalThis.String(object.toToken) : "",
            amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
            maxSlippage: isSet(object.maxSlippage) ? globalThis.Number(object.maxSlippage) : 0,
        };
    },

    toJSON(message: SwapRequest): unknown {
        const obj: any = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.fromToken !== "") {
            obj.fromToken = message.fromToken;
        }
        if (message.toToken !== "") {
            obj.toToken = message.toToken;
        }
        if (message.amount !== 0) {
            obj.amount = message.amount;
        }
        if (message.maxSlippage !== 0) {
            obj.maxSlippage = Math.round(message.maxSlippage);
        }

        return obj;
    },

    create<I extends Exact<DeepPartial<SwapRequest>, I>>(base?: I): SwapRequest {
        return SwapRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SwapRequest>, I>>(object: I): SwapRequest {
        const message = createBaseSwapRequest();
        message.userId = object.userId ?? "";
        message.fromToken = object.fromToken ?? "";
        message.toToken = object.toToken ?? "";
        message.amount = object.amount ?? 0;
        message.maxSlippage = object.maxSlippage ?? 0;

        return message;
    },
};

function createBaseSwapResponse(): SwapResponse {
    return { code: 0, message: "", txHash: "" };
}

export const SwapResponse: MessageFns<SwapResponse> = {
    encode(message: SwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.code !== 0) {
            writer.uint32(8).int32(message.code);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.txHash !== "") {
            writer.uint32(26).string(message.txHash);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SwapResponse {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwapResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.code = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.message = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.txHash = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): SwapResponse {
        return {
            code: isSet(object.code) ? globalThis.Number(object.code) : 0,
            message: isSet(object.message) ? globalThis.String(object.message) : "",
            txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
        };
    },

    toJSON(message: SwapResponse): unknown {
        const obj: any = {};
        if (message.code !== 0) {
            obj.code = Math.round(message.code);
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        if (message.txHash !== "") {
            obj.txHash = message.txHash;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<SwapResponse>, I>>(base?: I): SwapResponse {
        return SwapResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SwapResponse>, I>>(object: I): SwapResponse {
        const message = createBaseSwapResponse();
        message.code = object.code ?? 0;
        message.message = object.message ?? "";
        message.txHash = object.txHash ?? "";
        return message;
    },
};

/** Service for handling swaps */
export type SwapServiceService = typeof SwapServiceService;
export const SwapServiceService = {
    executeSwap: {
        path: "/defi.SwapService/ExecuteSwap",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: SwapRequest) => Buffer.from(SwapRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => SwapRequest.decode(value),
        responseSerialize: (value: SwapResponse) => Buffer.from(SwapResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) => SwapResponse.decode(value),
    },
} as const;

export interface SwapServiceServer extends UntypedServiceImplementation {
    executeSwap: handleUnaryCall<SwapRequest, SwapResponse>;
}

export interface SwapServiceClient extends Client {
    executeSwap(request: SwapRequest, callback: (error: ServiceError | null, response: SwapResponse) => void): ClientUnaryCall;
    executeSwap(request: SwapRequest, metadata: Metadata, callback: (error: ServiceError | null, response: SwapResponse) => void): ClientUnaryCall;
    executeSwap(
        request: SwapRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: SwapResponse) => void
    ): ClientUnaryCall;
}

export const SwapServiceClient = makeGenericClientConstructor(SwapServiceService, "defi.SwapService") as unknown as {
    new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SwapServiceClient;
    service: typeof SwapServiceService;
    serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
    ? ReadonlyArray<DeepPartial<U>>
    : T extends {}
    ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
